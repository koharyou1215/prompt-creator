Batch 1: 基盤レイヤー
prisma/schema.prisma
src/lib/env.ts
src/lib/ai/models.ts
src/lib/ai/openrouter.ts
src/lib/validation/schemas.ts
src/lib/api/errors.ts
Batch 2: APIルート
src/app/api/prompts/route.ts
src/app/api/prompts/[id]/route.ts
src/app/api/settings/route.ts
src/app/api/translate/route.ts
src/app/api/ai-suggest/route.ts
Batch 3: 型・ロジック
src/types/prompt.ts ほか
src/lib/ai/prompt-parser.ts
src/lib/ai/character-extractor.ts
src/lib/prompt/variations.ts
Batch 4: ストア・フック
src/stores/settingsStore.ts
src/stores/promptStore.ts
src/stores/compareStore.ts
src/hooks/usePromptEditor.ts（競合検知ヘッダ対応）
Batch 5: UI
src/components/settings/SettingsModal.tsx（日本語ラベル）
主要コンポーネントの修正済み断片
ここから出力開始します。
Batch 1/5: 基盤レイヤー —
1) prisma/schema.prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String             @id @default(cuid())
  email         String             @unique
  name          String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  prompts       Prompt[]
  templates     Template[]
  customDict    CustomDictionary[]
  settings      UserSettings?
  characters    Character[]
  histories     PromptHistory[]
}

model Prompt {
  id            String           @id @default(cuid())
  title         String
  content       String           @db.Text
  language      String           @default("en")
  parameters    Json             @default("{}")
  metadata      Json             @default("{}")

  userId        String
  user          User             @relation(fields: [userId], references: [id])
  elements      Element[]
  tags          Tag[]            @relation("PromptTags")
  versions      Version[]
  images        GeneratedImage[]
  characters    Character[]      @relation("CharacterPrompts", references: [id])
  promptCollections PromptCollection[] @relation("CollectionPrompts")

  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // パフォーマンス向上のためのインデックス
  @@index([userId])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([userId, language])
  // 全文検索は DB 構成に依存するため、マイグレーション後に手動で GIN / pg_trgm 等の設定を追加してください。
}

model Element {
  id         String   @id @default(cuid())
  type       String
  content    String   @db.Text
  position   Int
  isLocked   Boolean  @default(false)
  variations Json     @default("[]")
  metadata   Json?

  promptId   String
  prompt     Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@index([promptId])
  @@unique([promptId, position])
}

model Version {
  id            String   @id @default(cuid())
  versionNumber Int
  content       String   @db.Text
  elements      Json
  changes       Json
  comment       String?

  promptId      String
  prompt        Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())

  @@index([promptId])
  @@unique([promptId, versionNumber])
}

model Template {
  id          String   @id @default(cuid())
  name        String
  description String?
  content     String   @db.Text
  type        String
  category    String
  tags        Json     @default("[]")
  isPublic    Boolean  @default(false)

  userId      String
  user        User     @relation(fields: [userId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([category])
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  prompts   Prompt[] @relation("PromptTags")
  createdAt DateTime @default(now())
}

model GeneratedImage {
  id           String   @id @default(cuid())
  url          String
  thumbnailUrl String?
  platform     String
  metadata     Json?

  promptId     String
  prompt       Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now())

  @@index([promptId])
}

model CustomDictionary {
  id          String   @id @default(cuid())
  term        String
  translation String
  language    String
  category    String?

  userId      String
  user        User     @relation(fields: [userId], references: [id])

  createdAt   DateTime @default(now())

  @@unique([userId, term, language])
}

model UserSettings {
  id            String   @id @default(cuid())
  defaultLang   String   @default("ja")
  autoTranslate Boolean  @default(true)
  autoSave      Boolean  @default(true)
  theme         String   @default("light")
  preferences   Json     @default("{}")

  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id])

  updatedAt     DateTime @updatedAt
}

model PromptHistory {
  id        String   @id @default(cuid())
  promptId  String
  prompt    Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)

  action    String
  changes   Json
  metadata  Json?
  timestamp DateTime @default(now())

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  @@index([promptId])
  @@index([userId])
  @@index([timestamp])
  @@index([action])
}

model Character {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  appearance  Json
  personality Json
  style       Json
  metadata    Json
  tags        Json     @default("[]")
  usageCount  Int      @default(0)

  userId      String
  user        User     @relation(fields: [userId], references: [id])

  prompts     Prompt[] @relation("CharacterPrompts")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([name])
  @@index([usageCount])
}
​
2) src/lib/env.ts
// src/lib/env.ts
import { z } from 'zod';

const EnvSchema = z.object({
  DATABASE_URL: z.string().url(),
  OPENROUTER_API_KEY: z.string().min(1),
  NEXT_PUBLIC_APP_URL: z.string().url().optional(),
  UPSTASH_REDIS_REST_URL: z.string().url().optional(),
  UPSTASH_REDIS_REST_TOKEN: z.string().optional(),
  AUTH_SECRET: z.string().optional(),
  DEEPL_API_KEY: z.string().optional(),
  SENTRY_DSN: z.string().optional(),
});

export const env = EnvSchema.parse({
  DATABASE_URL: process.env.DATABASE_URL,
  OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,
  NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
  UPSTASH_REDIS_REST_URL: process.env.UPSTASH_REDIS_REST_URL,
  UPSTASH_REDIS_REST_TOKEN: process.env.UPSTASH_REDIS_REST_TOKEN,
  AUTH_SECRET: process.env.AUTH_SECRET,
  DEEPL_API_KEY: process.env.DEEPL_API_KEY,
  SENTRY_DSN: process.env.SENTRY_DSN,
});
​
3) src/lib/ai/models.ts
// src/lib/ai/models.ts
export type LLMProvider = 'anthropic' | 'openai' | 'google' | 'meta';

export const AVAILABLE_MODELS = [
  { id: 'anthropic/claude-3-haiku', label: 'Claude 3 Haiku', provider: 'anthropic' },
  { id: 'anthropic/claude-3-sonnet', label: 'Claude 3 Sonnet', provider: 'anthropic' },
  { id: 'openai/gpt-4o-mini', label: 'GPT-4o mini', provider: 'openai' },
] as const;

export type ModelId = typeof AVAILABLE_MODELS[number]['id'];

export const DEFAULT_MODELS: Record<'optimize' | 'translate' | 'analysis', ModelId> = {
  optimize: 'anthropic/claude-3-sonnet',
  translate: 'anthropic/claude-3-haiku',
  analysis: 'anthropic/claude-3-sonnet',
};
​
4) src/lib/ai/openrouter.ts
// src/lib/ai/openrouter.ts
import { env } from '@/lib/env';

type RequestOptions = { retries?: number; timeoutMs?: number; idempotencyKey?: string };

export class OpenRouterClient {
  private apiKey = env.OPENROUTER_API_KEY;
  private baseURL = 'https://openrouter.ai/api/v1';

  // 簡易サーキットブレーカー
  private failureCount = 0;
  private lastFailureAt: number | null = null;
  private circuitOpenUntil: number | null = null;

  private isCircuitOpen() {
    if (!this.circuitOpenUntil) return false;
    return Date.now() < this.circuitOpenUntil;
  }

  private recordFailure() {
    this.failureCount += 1;
    this.lastFailureAt = Date.now();
    if (this.failureCount >= 5) {
      // サーキットを30秒間オープン
      this.circuitOpenUntil = Date.now() + 30_000;
      this.failureCount = 0;
    }
  }

  private recordSuccess() {
    this.failureCount = 0;
    this.circuitOpenUntil = null;
  }

  private calculateBackoff(attempt: number) {
    return Math.min(500 * Math.pow(2, attempt - 1), 5000);
  }

  private async delay(ms: number) {
    return new Promise((r) => setTimeout(r, ms));
  }

  private buildHeaders(idempotency?: string) {
    return {
      Authorization: `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': env.NEXT_PUBLIC_APP_URL || '',
      ...(idempotency ? { 'Idempotency-Key': idempotency } : {}),
    } as Record<string, string>;
  }

  private async executeWithRetry(path: string, body: any, opts?: RequestOptions, signal?: AbortSignal) {
    const retries = opts?.retries ?? 3;
    const idempotency = opts?.idempotencyKey ?? (globalThis.crypto?.randomUUID?.() ?? `${Date.now()}`);

    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const res = await fetch(`${this.baseURL}${path}`, {
          method: 'POST',
          headers: this.buildHeaders(idempotency),
          body: JSON.stringify(body),
          signal,
        });

        if (res.status === 429) {
          const retryAfter = res.headers.get('retry-after');
          const delayMs = retryAfter ? parseInt(retryAfter, 10) * 1000 : this.calculateBackoff(attempt);
          await this.delay(delayMs);
          continue;
        }

        if (!res.ok && res.status >= 500 && attempt < retries) {
          await this.delay(this.calculateBackoff(attempt));
          continue;
        }

        return res;
      } catch (err) {
        if (attempt === retries) throw err;
        await this.delay(this.calculateBackoff(attempt));
      }
    }
    throw new Error('Retries exhausted');
  }

  private enhanceError(e: any) {
    if (e instanceof Error) return new Error(`OpenRouterClient error: ${e.message}`);
    return new Error('OpenRouterClient unknown error');
  }

  private async request(path: string, body: any, opts?: RequestOptions) {
    const timeoutMs = opts?.timeoutMs ?? 30_000;
    if (this.isCircuitOpen()) throw new Error('OpenRouter service temporarily unavailable');

    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);

    try {
      const res = await this.executeWithRetry(path, body, opts, controller.signal);
      this.recordSuccess();
      return res;
    } catch (err) {
      this.recordFailure();
      throw this.enhanceError(err);
    } finally {
      clearTimeout(timer);
    }
  }

  async complete(prompt: string, model: string) {
    const res = await this.request('/chat/completions', {
      model,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7,
    });
    if (!res.ok) throw new Error(`OpenRouter API error: ${res.status} ${res.statusText}`);
    const data = await res.json();
    return data.choices?.[0]?.message?.content as string;
  }
}
​
5) src/lib/validation/schemas.ts
// src/lib/validation/schemas.ts
import { z } from 'zod';
import { AVAILABLE_MODELS } from '@/lib/ai/models';

export const PromptCreateSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().min(1).max(8000),
  language: z.string().default('en'),
  parameters: z.record(z.any()).default({}),
  metadata: z.record(z.any()).default({}),
  tags: z.array(z.string()).optional(),
});

export const PromptUpdateSchema = PromptCreateSchema.partial();

const modelEnum = z.enum(AVAILABLE_MODELS.map(m => m.id) as [string, ...string[]]);

export const SettingsSchema = z.object({
  defaultLang: z.string().default('ja'),
  autoTranslate: z.boolean().default(true),
  autoSave: z.boolean().default(true),
  theme: z.enum(['light', 'dark']).default('light'),
  modelOptimize: modelEnum,
  modelTranslate: modelEnum,
  modelAnalysis: modelEnum,
});

export const TranslateRequestSchema = z.object({
  text: z.string().min(1),
  sourceLang: z.string().min(2),
  targetLang: z.string().min(2),
  useCustomDict: z.boolean().optional(),
  context: z.string().optional(),
});

export const AISuggestRequestSchema = z.object({
  prompt: z.string().min(1),
  type: z.enum(['optimize', 'variations', 'enhance']),
  options: z.record(z.any()).optional(),
});
​
6) src/lib/api/errors.ts
// src/lib/api/errors.ts
import { NextResponse } from 'next/server';

export const unauthorized = () =>
  NextResponse.json({ error: { code: 'UNAUTHORIZED', message: 'Unauthorized' } }, { status: 401 });

export const badRequest = (msg = 'Bad request', details?: any) =>
  NextResponse.json({ error: { code: 'BAD_REQUEST', message: msg, details } }, { status: 400 });

export const notFound = (msg = 'Not found') =>
  NextResponse.json({ error: { code: 'NOT_FOUND', message: msg } }, { status: 404 });

export const conflict = (msg = 'Conflict') =>
  NextResponse.json({ error: { code: 'CONFLICT', message: msg } }, { status: 409 });

export const serverError = (msg = 'Server error') =>
  NextResponse.json({ error: { code: 'SERVER_ERROR', message: msg } }, { status: 500 });